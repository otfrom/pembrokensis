#+TITLE: Pembrokensis
#+AUTHOR: Bruce Durling
#+EMAIL: bld@otfrom.com
#+PROPERTY: header-args :mkdirp yes :noweb-prefix no
#+options: toc:4 num:t author:t email:t
#+startup: content indent
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

*Last revised and exported on {{{latest-export-date}}} with a word
count of {{{word-count}}}.*

Pembrokensis is one of the [[https://github.com/corgi-emacs/corgi][corgwn]] with a name inspired by [[https://github.com/bodil][Bodil
Stokke]]'s account for her corgi [[https://kneel.before.dog/users/bark_maul][Abeloth Penfro KC]].

I want to make a few changes to how corgi works though, and I'd like
it to be in a literate style to explain what I'm doing. So I'm using
[[https://orgmode.org/worg/org-contrib/babel/intro.html][org-babel]].

Most of what we want to steal, or rather be inspired by, is in
[[https://github.com/corgi-emacs/corgi-packages][corgi-packages]]. One of my first choices is that I don't want to use
[[https://github.com/radian-software/straight.el][straight]] as [[https://www.gnu.org/software/emacs/manual/html_node/use-package/][use-package]] is now part of emacs and there is a [[https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=2ce279680bf9c1964e98e2aa48a03d6675c386fe][:vc
keyword]] in use-package so you don't need it for random sources from
git forges.

[[https://github.com/bloat][Andrew Cowper]] gave a talk at Skillsmatter (RIP) many years ago, which is why I
started making literate configurations and doing literate programming, but
[[https://howardism.org/][Howard Abrams]] was the one who inspired me to get back into it. Howard's
[[https://github.com/howardabrams/dot-files][magisterial dot files]] can inspire you well. I'm going to be borrowing a lot from
[[https://protesilaos.com/][Prot]]'s [[https://protesilaos.com/emacs/dotemacs][literate emacs config]] too.

I learned about Howard's work via [[https://emacsconf.org/][emacsconf]], which is organised by [[https://sachachua.com/blog/][Sacha Chua]]
who has been an inspiration to me and the reason why I moved away from
[[https://github.com/jwiegley/remember/blob/master/remember.el][remember.el]] to org-mode in the first place. I've always found the stuff in
Sacha's config a bit intimidating, but there is still [[https://sachachua.com/dotemacs/index.html][a lot of inspiration]] to be
had and of course Sacha's [[https://sachachua.com/blog/category/emacs-news/][Emacs Weekly News]].

Thanks to [[https://mathstodon.xyz/@anemofilia/113803804376833799][anemofilia]] I've learned more about [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][noweb syntax]] and how [[https://social.boiledscript.com/@hako][hako]]
configures [[https://codeberg.org/hako/Testament/src/branch/trunk/cfg/dorphine.org][dorphine]] and [[https://codeberg.org/hako/Testament/src/branch/trunk/cfg/gokuraku.org][gokuraku]] for Guix.

* Things I'd like to be able to do

That I haven't figured out yet.

 - Have a link to the org section and the org-text as comments on the
   noweb file. I know how to do it if I just tangle this file, but I'd
   like to have one file with multiple outputs.
 - Have a Table of Contents Show up when I push to github. Do I need
   to export the file instead? Who knows?

* Files to Create

** early-init.el

This gets called first and before much has happened. It is where we
need to set things like our package installation strategy.

#+begin_src emacs-lisp :tangle early-init.el :noweb yes
  ;;; early-init --- Initialise emacs

  ;;; Commentary:

  ;; This has been produced from README.org

  ;;; Code:

  ;; This is where we define things that happen very early in startup
  <<gc-config>>

  <<early-init-helpers>>

  <<early-init-packages>>

  (provide 'early-init)
  ;;; early-init.el ends here.
#+end_src

** init.el

This is the bulk of the emacs configuration.

I think I can get away with the following:

 - get evil basics working
 - I can do my own clojure and emacs-lisp set up (along with everything else)
 - corkey using ~package-vc-install~
 - my own copies of corgi-keys.el, corgi-signals.el, user-keys.el, and
   user-signals.el on my loadpath, as that is all the corgi-bindings is
   providing.
 - my own copy of corgi-stateline, partly because I'd like it to use colours
   from ef-themes or something else. What I really want is for the whole colour
   scheme of an editable window to change, but I still need to figure out how to
   change the scheme of a single window.
 - I can do my own


#+begin_src emacs-lisp :tangle init.el :noweb yes
  ;;; init --- Initialise emacs

  ;;; Commentary:

  ;; This has been produced from README.org

  ;;; Code:

  ;;; Helpers
  <<init-helpers>>

  ;;; Defaults
  <<pembrokensis-defaults>>

  ;;; Editor
  <<pembrokensis-editor>>

  ;;; Completion UI
  <<pembrokensis-completion-ui>>

  ;;; pembrokensis-commands
  <<pembrokensis-commands>>

  ;;; pembrokensis-clojure
  <<pembrokensis-clojure>>

  ;;; pembrokensis-emacs-lisp
  <<pembrokensis-emacs-lisp>>

  ;;; pembrokensis-stateline
  <<pembrokensis-stateline>>

  ;;; pembrokensis-corgi-bindings
  <<pembrokensis-corgi-bindings>>

  ;;; pembrokensis-corkey
  <<pembrokensis-corkey>>

  ;;; evil-escape
  <<evil-escape>>

  ;;; Other Modes
  <<magit>>

  ;;; Coda
  <<init-coda>>

  (provide 'init)
  ;;; init.el ends here.
#+end_src

** mastodonc-init.el

I'm helping out a friend with their emacs configuration. They don't
want nearly as much as I do, so they'll need a different init.el to
copy over. I'd like to produce that from here.

#+begin_src emacs-lisp :tangle mastodonc-init.el :noweb yes
  ;;; init --- Initialise emacs

  ;;; Commentary:

  ;; This has been produced from README.org

  ;;; Code:

  ;;; Helpers
  <<init-helpers>>

  ;;; Defaults
  <<pembrokensis-defaults>>

  ;;; Editor
  <<pembrokensis-editor>>

  ;;; Completion UI
  <<pembrokensis-completion-ui>>

  ;;; pembrokensis-commands
  <<pembrokensis-commands>>

  ;;; pembrokensis-clojure
  <<pembrokensis-clojure>>

  ;;; pembrokensis-emacs-lisp
  <<pembrokensis-emacs-lisp>>

  ;;; pembrokensis-stateline
  <<pembrokensis-stateline>>

  ;;; pembrokensis-corgi-bindings
  <<pembrokensis-corgi-bindings>>

  ;;; pembrokensis-corkey
  <<pembrokensis-corkey>>

  ;;; evil-escape
  <<evil-escape>>

  ;;; Other Modes
  <<magit>>

  ;;; Coda
  <<init-coda>>

  (provide 'init)
  ;;; init.el ends here.
#+end_src

** user-keys.el

#+begin_src emacs-lisp :tangle user-keys.el :noweb yes
  ;;; -*- no-byte-compile: t -*-

  ;; This is your user keys file, here you can configure key bindings that will
  ;; get added to Corgi. You can also override Corgi's default bindings this way.
  ;;
  ;; Bindings here are nested, e.g. `("SPC" ("b" ("k" kill-buffer)))' means that
  ;; "space" followed by "b" and then "k" will invoke `M-x kill-buffer'.
  ;;
  ;; You can add a descriptions before the command, this will show up in a pop-up
  ;; when you press the prefix key and wait a bit. (This uses which-key)
  ;;
  ;; `("SPC" ("b" ("k" "Choose a buffer to kill" kill-buffer)))'
  ;;
  ;; Instead of a prefix key you can use a symbol like `normal' or `insert', which
  ;; designates the Evil state (what vim calls the mode). `global' means any
  ;; state, `normal|visual' means either normal or visual.
  ;;
  ;; Instead of a command like `kill-buffer' you can put a keyword like
  ;; `:eval/buffer'. This is called a "signal". In the `corgi-signals' (or
  ;; `user-signals') file these are bound to specific commands based on the major
  ;; mode. E.g. in Emacs Lisp `:eval/buffer' means `eval-buffer', whereas in
  ;; Clojure it means `cider-eval-buffer'.

  (bindings
   ;; "global" bindings are always active regardless of Evil's "state" (= vim mode)
   ;; If you don't provide this the default is `normal'.
   (global
    )

   ;; Bindings for commands are usually only active in normal and visual state.
   (normal|visual
    ("SPC"
     ("0" "Select Treemacs" treemacs-select-window)
     ("f"
      ("t" "Turn Treemacs on/off" treemacs)
      ("T" "Focus current file in file tree" treemacs-find-file))
     )))
#+end_src

** user-signals

#+begin_src emacs-lisp :tangle user-signals.el :noweb yes
  ;;; -*- no-byte-compile: t -*-

  ;; This is your user signals file, here you configure how certain signals are
  ;; handled in specific modes.

  ;; In this Corgi sample config we've included `js-comint' to demonstrate how
  ;; that works. This package allows evaluating JavaScript directly from a buffer.
  ;; Evaluating the expression before the cursor is done in Corgi with `, RET' (or
  ;; `, e e'), by telling Corgi that in JS buffers this means `js-send-last-sexp'
  ;; we get the same bindings there.
  ;;
  ;; If you prefer some other key binding for "eval", then you can do that in
  ;; `user-keys.el', and your new binding will do the right thing regardless of
  ;; the language/mode you are in.

  ((js-mode ( :eval/last-sexp js-send-last-sexp
              :eval/buffer js-send-buffer
              :eval/region js-send-region
              :repl/toggle js-comint-start-or-switch-to-repl)))
#+end_src

** TODO guix configuration

** TODO nix configuration

Well, part of the nix configuration anyway, the bit that install all the emacs
packages I need.

#+begin_src nix :tangle config-fragment.nix :noweb yes
  <<epkgs>>
#+end_src


* Package Installation

If we're on a wild west distro like [[https://ubuntu.com/][Ubuntu]] then we're going to want to
install packages from elpa and melpa. If we're on something like [[https://guix.gnu.org/][Guix]],
[[https://lix.systems/][lix]], or [[https://nixos.org/][NixOS]] then we want to use the internal package manager for
everything and not do it via this particular configuration.

** Where are we?

We can often (or at least often enough for NixOS, Ubuntu, and Guix),
tell what distro we are on by checking the NAME in ~/etc/os-release~
which we can then use to do the right thing in later package ensuring.

#+begin_src emacs-lisp :noweb-ref early-init-helpers
  (setq os-release
        (with-temp-buffer
          (insert-file-contents "/etc/os-release")
          (re-search-forward "^NAME\\W*\\(\\w+\\)")
          (match-string 1)))

  (setq nixos-p (string= "NixOS" os-release))

  (setq ubuntu-p (string= "Ubuntu" os-release))

  (setq guix-p (string= "Guix" os-release))
#+end_src

** Turn on Packages Installation as Needed

*** Package Settings

Since Emacs 27.1 we have to disable package.el in the early init file
if we don't want to use it. We will use it for Ubuntu, but we won't in
Guix or NixOS.

    #+BEGIN_SRC emacs-lisp :noweb-ref early-init-packages
      (if ubuntu-p
          (progn
            (setopt package-enable-at-startup t)
            (package-initialize))
        (setopt package-enable-at-startup nil))
    #+END_SRC

    Prefer newer to avoid Emacs loading older byte-compiled files and accidentally
    old code to end up in depending files that are about to be byte-compiled.

    #+begin_src emacs-lisp :noweb-ref early-init-packages
    (setopt load-prefer-newer t)
    #+end_src

* early-init setup

We want to set things in early init to speed up startup as we have a
lot more ram now than when emacs was thought of as *Eight Megs and
Continuously Swapping*. This is from the [[https://github.com/corgi-emacs/corgi/blob/main/sample-config/early-init.el][corgi sample config
early-init.el]].

#+begin_src emacs-lisp :noweb-ref gc-config
  (setq gc-cons-threshold most-positive-fixnum ; 2^61 bytes
        gc-cons-percentage 0.6)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold 33554432 ; 32mb
                    gc-cons-percentage 0.1)))
#+end_src

* Pembrokensis Defaults

https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Fetching-Package-Sources
https://elpa.gnu.org/devel/doc/use-package.html#Installing-packages

This is stolen from [[https://github.com/corgi-emacs/corgi-packages/blob/main/corgi-defaults/corgi-defaults.el][corgi-defaults]]

#+begin_src emacs-lisp :noweb-ref pembrokensis-defaults
  ;; Change a bunch of Emacs defaults, from disabling the menubar and toolbar,
  ;; to fixing modifier keys on Mac and disabling the system bell.
  (use-package emacs
    :init
    (setq inhibit-startup-message t)

    ;; Allow pasting selection outside of Emacs
    (setq select-enable-clipboard t)

    ;; Show keystrokes in progress
    (setq echo-keystrokes 0.1)

    ;; Move files to trash when deleting
    (setq delete-by-moving-to-trash t)

    ;; Real emacs knights don't use shift to mark things
    (setq shift-select-mode nil)

    ;; Always display line and column numbers
    (setq line-number-mode t)
    (setq column-number-mode t)

    ;; Lines should be 80 characters wide, not 72
    (setq fill-column 80)
    (set-default 'fill-column 80)

    ;; Never insert tabs
    (set-default 'indent-tabs-mode nil)

    ;; Show me empty lines after buffer end
    (set-default 'indicate-empty-lines t)

    ;; Don't break lines for me, please
    ;; (setq-default truncate-lines t)

    ;; Allow recursive minibuffers
    (setq enable-recursive-minibuffers t)

    ;; Don't be so stingy on the memory, we have lots now. It's the distant future.
    (setq gc-cons-threshold 2000000)

    ;; Sentences do not need double spaces to end. Period.
    (set-default 'sentence-end-double-space nil)

    ;; Nic says eval-expression-print-level needs to be set to nil (turned off) so
    ;; that you can always see what's happening.
    (setq eval-expression-print-level nil)

    :config
    (if (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    (if (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (if (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))

    ;; UTF-8 please
    (setq locale-coding-system 'utf-8)   ; pretty
    (set-terminal-coding-system 'utf-8)  ; pretty
    (set-keyboard-coding-system 'utf-8)  ; pretty
    (set-selection-coding-system 'utf-8) ; please
    (prefer-coding-system 'utf-8)        ; with sugar on top

    ;; Show active region
    (transient-mark-mode 1)
    (make-variable-buffer-local 'transient-mark-mode)
    (put 'transient-mark-mode 'permanent-local t)
    (setq-default transient-mark-mode t)

    ;; When Emacs is ran in GUI mode, configure common Emoji fonts, making it more
    ;; likely that Emoji will work out of the box
    (when (display-graphic-p)
      (set-fontset-font t 'symbol "Apple Color Emoji")
      (set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
      (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'append)
      (set-fontset-font t 'symbol "Symbola" nil 'append)))

  (use-package subword
    :config
    ;; Easily navigate sillycased words
    (global-subword-mode 1))

  (use-package files
    :init
    ;; Don't make backup~ files
    ;; (setq make-backup-files nil)

    (when (not (file-directory-p (expand-file-name "backups" user-emacs-directory)))
      (make-directory (expand-file-name "backups" user-emacs-directory)))

    (when (not (file-directory-p (expand-file-name "auto-save-list" user-emacs-directory)))
      (make-directory (expand-file-name "auto-save-list" user-emacs-directory)))

    ;; Put backups and auto-save files in subdirectories, so the
    ;; user-emacs-directory doesn't clutter
    (setq backup-directory-alist
          `(("." . ,(expand-file-name "backups" user-emacs-directory)))
          auto-save-file-name-transforms
          `((".*" ,(expand-file-name "auto-save-list/" user-emacs-directory) t))))

  (use-package electric
    :init
    ;; No electric indent
    (setq electric-indent-mode nil))

  (use-package uniquify
    :init
    (setq uniquify-buffer-name-style 'forward))

  (use-package vc
    :init
    ;; Stop asking about following symlinks to version controlled files
    (setq vc-follow-symlinks t))

  (use-package terminal
    :init
    (setq ring-bell-function 'ignore))

  ;; Auto refresh buffers
  ;; Also auto refresh dired, but be quiet about it
  (use-package autorevert
    :init
    (setq global-auto-revert-non-file-buffers t)
    (setq auto-revert-verbose nil)
    :config
    (add-hook 'dired-mode-hook #'auto-revert-mode)
    (global-auto-revert-mode 1))

  ;; Transparently open compressed files
  (use-package jka-cmpr-hook
    :config
    (auto-compression-mode t))

  ;; Enable syntax highlighting for older Emacsen that have it off
  (use-package font-core
    :config
    (global-font-lock-mode t))
#+end_src

* Pembrokensis Editor

This is stolen from [[https://github.com/corgi-emacs/corgi-packages/blob/main/corgi-editor/corgi-editor.el][corgi-editor]]. The important thing here is setting up [[https://github.com/emacs-evil/evil][evil]].

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  ;; UI configuration for that Corgi-feel. This sets up a bunch of packages like
  ;; Evil, Smartparens, Aggressive indent, Rainbow parens, expand region etc.
  ;; (use-package corgi-editor)
#+end_src

** avy for jumping around

#+begin_src nix :noweb-ref epkgs
  epkgs.avy
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package avy)
#+end_src

** undo-fu, as evil needs it

I'm not sure about [[https://codeberg.org/ideasman42/emacs-undo-fu][undo-fu]]. According to the [[https://github.com/emacs-evil/evil?tab=readme-ov-file#dependencies][dependencies]] of evil we
either need this or [[https://gitlab.com/tsc25/undo-tree][undo-tree]].

#+begin_src nix :noweb-ref epkgs
  epkgs.undo-fu
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package undo-fu)
#+end_src

** evil

#+begin_quote
[[https://github.com/emacs-evil/evil][Evil]] is an extensible vi layer for Emacs. It emulates the main
features of [[https://github.com/emacs-evil/evil][Vim]], and provides facilities for writing custom
extensions. Also see our page on [[https://www.emacswiki.org/emacs/Evil][EmacsWiki]].
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.evil
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package evil
    :init (setq evil-want-keybinding nil)
    :config
    (evil-mode t)
    (evil-set-undo-system 'undo-fu)
    (setq evil-move-cursor-back nil
          evil-move-beyond-eol t
          evil-want-fine-undo t
          evil-mode-line-format 'before
          evil-normal-state-cursor '(box "orange")
          evil-insert-state-cursor '(box "green")
          evil-visual-state-cursor '(box "#F86155")
          evil-emacs-state-cursor  '(box "purple"))

    ;; Prevent evil-motion-state from shadowing previous/next sexp
    (require 'evil-maps)
    (define-key evil-motion-state-map "L" nil)
    (define-key evil-motion-state-map "M" nil))
#+end_src

** evil-collection

Evil really corrupts everything (I joke, or do I?) and that means we
need to start adding in other bindings as well.

#+begin_quote
This is a collection of Evil bindings for the parts of Emacs that Evil
does not cover properly by default, such as help-mode, M-x calendar,
Eshell and more.

Warning: Expect some default bindings to change in the future.
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.evil-collection
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package evil-collection
    :after (evil)
    :diminish evil-collection-unimpaired-mode
    :config
    (evil-collection-init))
#+end_src

** evil-surround

#+begin_quote
[[https://github.com/emacs-evil/evil-surround][This]] package emulates surround.vim by Tim Pope. The functionality is
wrapped into a minor mode.

This package uses Evil as its vi layer.
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.evil-surround
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package evil-surround
    :config (global-evil-surround-mode 1))
#+end_src


** which-key

#+begin_src nix :noweb-ref epkgs
  epkgs.which-key
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package which-key
    :diminish which-key-mode
    :config
    (which-key-mode 1)
    (setq which-key-sort-order 'which-key-prefix-then-key-order))
#+end_src

** ace-window instead of winum

Corgi uses [[https://github.com/corgi-emacs/corgi-packages/blob/36254ff552d0ee0f5c50d6a29ecfd75b0cf503a1/corgi-editor/corgi-editor.el#L56][winum]] to go to different windows, I'd like to use
[[https://github.com/abo-abo/ace-window][ace-window]] instead as we already have avy for other jumping.

#+begin_quote
I'm sure you're aware of the other-window command. While it's great
for two windows, it quickly loses its value when there are more
windows. You need to call it many times, and since it's not easily
predictable, you have to check each time if you're in the window that
you wanted.

Another approach is to use windmove-left, windmove-up, etc. These are
fast and predictable. Their disadvantage is that they need 4 key
bindings. The default ones are shift+arrows, which are hard to reach.

This package aims to take the speed and predictability of windmove and
pack it into a single key binding, similar to other-window.
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.ace-window
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package ace-window)
#+end_src

** smartparens rather than paredit

I've been a [[https://paredit.org/][paredit]] person for a very long time, but most evil people
like things like [[https://github.com/emacs-evil/evil-cleverparens][cleverparens]] and [[https://github.com/Fuco1/smartparens][smartparens]] instead, that are
supposed to "fix" the problems of paredit, which in fairness did sit
still for a very long time, as it all basically worked, but emacs
moved on in the meantime after a long period of being quiet until the
new maintainers took over.

I wonder if all of this might be replaced by something [[https://www.masteringemacs.org/article/how-to-get-started-tree-sitter][Tree-Sitter]]
based eventually.

*** smartparens

[[https://github.com/Fuco1/smartparens][smartparens]] tries to be a superset of all the other electric pair
modes.

#+begin_src nix :noweb-ref epkgs
  epkgs.smartparens
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package smartparens
    :init (require 'smartparens-config)
    :diminish smartparens-mode
    :hook (prog-mode . smartparens-mode))
#+end_src

*** cleverparens

#+begin_quote
evil-cleverparens is modal-editing optimized for editing Lisp. It
works under the following principles:

 - Act like Vim/evil where useful, but prevent actions that would
   throw the order of your parentheses and other delimiters into
   question.

 - Make the most out of the combination of structural and modal
   editing.

 - Provide but don't force additional features on the user.
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.evil-cleverparens
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  ;; We don't actually enable cleverparens, because most of their bindings we
  ;; don't want, we install our own bindings for specific sexp movements
  (use-package evil-cleverparens
    :after (evil smartparens))
#+end_src


** aggressive-indent

[[https://github.com/Malabarba/aggressive-indent-mode][Malabarba/aggressive-indent-mode]] Emacs minor mode that keeps your code
always indented. More reliable than electric-indent-mode.

#+begin_src nix :noweb-ref epkgs
  epkgs.aggressive-indent
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package aggressive-indent
    :diminish aggressive-indent-mode
    :hook ((clojurex-mode
            clojurescript-mode
            clojurec-mode
            clojure-mode
            emacs-lisp-mode
            lisp-data-mode
            js-mode
            piglet-mode)
           . aggressive-indent-mode))
#+end_src

** rainbow-delimiters

Because I like the colourful visual signal of what blocks go together.

#+begin_src nix :noweb-ref epkgs
  epkgs.rainbow-delimiters
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package rainbow-delimiters
    :hook ((cider-repl-mode
            clojurex-mode
            clojurescript-mode
            clojurec-mode
            clojure-mode
            emacs-lisp-mode
            lisp-data-mode
            inferior-emacs-lisp-mode)
           . rainbow-delimiters-mode))
#+end_src

** dumb-jump

[[https://github.com/jacktasia/dumb-jump#start-of-content][dumb-jump]] tries to fill in those places where things like CIDER or lsp
modes won't find things for you. I'm not sure about it, but let's try
it for a while.

#+begin_quote
Dumb Jump is an Emacs "jump to definition" package with support for
50+ programming languages that favors "just working". This means
minimal -- and ideally zero -- configuration with absolutely no stored
indexes (TAGS) or persistent background processes. Dumb Jump requires
at least GNU Emacs 24.3.
#+end_quote

#+begin_src nix :noweb-ref epkgs
  epkgs.dumb-jump
#+end_src


#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package dumb-jump)
#+end_src

** goto-last-change

#+begin_src nix :noweb-ref epkgs
  epkgs.goto-chg
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package goto-chg)
#+end_src

** expand-region

#+begin_src nix :noweb-ref epkgs
  epkgs.expand-region
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (use-package expand-region)
#+end_src

** string-edit-at-point

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  ;; (use-package string-edit-at-point)

#+end_src

** xclip

#+begin_src nix :noweb-ref epkgs
  epkgs.xclip
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  (when (and (not (display-graphic-p))
             (executable-find "xclip"))
    (use-package xclip
      :config
      (when (executable-find xclip-program)
        (with-no-warnings
          (xclip-mode t)))))
#+end_src

** Some helper functions

#+begin_src emacs-lisp :noweb-ref pembrokensis-editor
  ;; Offer to create parent directories if they do not exist
  ;; http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
  (defun magnars/create-non-existent-directory ()
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
        (make-directory parent-directory t))))

  (add-to-list 'find-file-not-found-functions #'magnars/create-non-existent-directory)

  (defvar corgi-editor--last-buffer
    nil
    "The last current buffer.")

  (defun corgi-editor/-on-buffer-change (&optional _win)
    (unless (or (and (minibufferp) (not evil-want-minibuffer))
                (eq (current-buffer) corgi-editor--last-buffer))
      (setq corgi-editor--last-buffer (current-buffer))
      (evil-change-to-initial-state)))

  (if (boundp 'window-buffer-change-functions)
      ;; Emacs 27.1+ only
      (add-hook 'window-buffer-change-functions #'corgi-editor/-on-buffer-change)
    (add-hook 'post-command-hook #'corgi-editor/-on-buffer-change))
#+end_src

* Completion UI

This is one of the places where I've strayed quite a bit from
corgi-completion-ui.

#+begin_src emacs-lisp
  ;; Interactive Completion user interface configuration. This sets up
  ;; a bunch of packages like Ivy (minibuffer completion), Swiper
  ;; (fuzzy search), Counsel, Projectile (project-aware commands),
  ;; Company (completion).
  ;; (use-package corgi-completion-ui)
#+end_src

** vertico-mode and orderless
:PROPERTIES:
:ID:       4bc8b4ed-bac4-4d71-a85e-c0e638c80766
:END:

#+begin_quote
Vertico provides a performant and minimalistic vertical completion UI
based on the default completion system. The focus of Vertico is to
provide a UI which behaves correctly under all circumstances. By
reusing the built-in facilities system, Vertico achieves full
compatibility with built-in Emacs completion commands and completion
tables.
#+end_quote

[[https://github.com/minad/vertico][vertico-mode]] is a replacement for things like [[https://company-mode.github.io/][company-mode]] for
completion in lots of different places. company-mode did lots of extra
things that aren’t needed as much in newer versions of emacs so is a
lot of extra code. vertico is hopefully smaller and easier to maintain
as it uses more of the features built into emacs 28 and beyond.

There are a lot of configuration suggestions on the github page in
that initial link. We’ll be stealing most of them and I’ll try to
highlight the places where we don’t use those suggestions.

Let’s get the vertico basics up and running. I’ll have a think about
what lines in this I want to uncomment later

#+begin_src nix :noweb-ref epkgs
  epkgs.vertico
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
;; Enable vertico
(use-package vertico
  ;; :custom
  ;; (vertico-scroll-margin 0) ;; Different scroll margin
  ;; (vertico-count 20) ;; Show more candidates
  ;; (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
  ;; (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
  :init
  (vertico-mode))
#+end_src

*** savehist-mode
:PROPERTIES:
:ID:       553a9a81-f14b-40fb-aa44-46e80260d561
:END:

It looks like it wants to use ~savehist-mode~ as well for things.

 #+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
   ;; Persist history over Emacs restarts. Vertico sorts by history position.
   (use-package savehist
     :init
     (savehist-mode))
#+end_src

And it wants us to configure some of the base things in Emacs itself


*** vertico specific Emacs configurations
:PROPERTIES:
:ID:       41687694-5375-492a-b70b-e8af5f5eaea1
:END:

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
;; A few more useful configurations...
(use-package emacs
  :custom
  ;; Support opening new minibuffers from inside existing minibuffers.
  (enable-recursive-minibuffers t)
  ;; Hide commands in M-x which do not work in the current mode.  Vertico
  ;; commands are hidden in normal buffers. This setting is useful beyond
  ;; Vertico.
  (read-extended-command-predicate #'command-completion-default-include-p)
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                    "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src

*** orderless
:PROPERTIES:
:ID:       8a25a266-b5cf-4075-b17d-f08700c3ae9b
:END:

And it wants us to put in [[https://github.com/oantolin/orderless][orderless]] too

#+begin_src nix :noweb-ref epkgs
  epkgs.orderless
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
;; Optionally use the `orderless' completion style.
(use-package orderless
  :custom
  ;; Configure a custom style dispatcher (see the Consult wiki)
  ;; (orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch))
  ;; (orderless-component-separator #'orderless-escapable-split-on-space)
  (completion-styles '(orderless basic))
  (completion-category-defaults nil)
  (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

There are a number of other [[https://github.com/minad/vertico?tab=readme-ov-file#complementary-packages][complementary packages]] that we are going
to use as well like [[id:cee7b9ba-aec3-4464-9f47-cdd09f6c8ffc][Marginalia]], Consult, and Embark. We’ve already put
in orderless.

** Marginalia and nerd icons
:PROPERTIES:
:ID:       cee7b9ba-aec3-4464-9f47-cdd09f6c8ffc
:END:

 gives us a lot more information about out minibuffer completions.

#+begin_src nix :noweb-ref epkgs
  epkgs.marginalia
#+end_src
#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
;; Enable rich annotations using the Marginalia package
(use-package marginalia
  ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
  ;; available in the *Completions* buffer, add it to the
  ;; `completion-list-mode-map'.
  :bind (:map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  ;; The :init section is always executed.
  :init

  ;; Marginalia must be activated in the :init section of use-package such that
  ;; the mode gets enabled right away. Note that this forces loading the
  ;; package.
  (marginalia-mode))
#+end_src

There is a suggestion to use nerd-icons as well

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
  ;; FIXME: This isn’t really giving us the results we want on nixos
  ;; (use-package nerd-icons-completion
  ;;   :after marginalia
  ;;   :config
  ;;   (nerd-icons-completion-mode)
  ;;   (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

FIXME: The nerd-icons don’t really seem to be working that well for me
at the moment though. I’m not sure what bit of nixos I have failed to
configure correctly.

** Consult

#+begin_quote
Consult provides search and navigation commands based on the Emacs
completion function completing-read. Completion allows you to quickly
select an item from a list of candidates. Consult offers asynchronous
and interactive consult-grep and consult-ripgrep commands, and the
line-based search command consult-line. Furthermore Consult provides
an advanced buffer switching command consult-buffer to switch between
buffers, recently opened files, bookmarks and buffer-like candidates
from other sources.
#+end_quote

[[https://github.com/minad/consult][consult]]

#+begin_src nix :noweb-ref epkgs
  epkgs.consult
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
;; Example configuration for Consult
(use-package consult
  ;; Replace bindings. Lazily loaded by `use-package'.
  :bind (;; C-c bindings in `mode-specific-map'
         ("C-c M-x" . consult-mode-command)
         ("C-c h" . consult-history)
         ("C-c k" . consult-kmacro)
         ("C-c m" . consult-man)
         ("C-c i" . consult-info)
         ([remap Info-search] . consult-info)
         ;; C-x bindings in `ctl-x-map'
         ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
         ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
         ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
         ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
         ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
         ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
         ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
         ;; Custom M-# bindings for fast register access
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
         ("C-M-#" . consult-register)
         ;; Other custom bindings
         ("M-y" . consult-yank-pop)                ;; orig. yank-pop
         ;; M-g bindings in `goto-map'
         ("M-g e" . consult-compile-error)
         ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
         ("M-g g" . consult-goto-line)             ;; orig. goto-line
         ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
         ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-imenu-multi)
         ;; M-s bindings in `search-map'
         ("M-s d" . consult-find)                  ;; Alternative: consult-fd
         ("M-s c" . consult-locate)
         ("M-s g" . consult-grep)
         ("M-s G" . consult-git-grep)
         ("M-s r" . consult-ripgrep)
         ("M-s l" . consult-line)
         ("M-s L" . consult-line-multi)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ;; Isearch integration
         ("M-s e" . consult-isearch-history)
         :map isearch-mode-map
         ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
         ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
         ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
         ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
         ;; Minibuffer history
         :map minibuffer-local-map
         ("M-s" . consult-history)                 ;; orig. next-matching-history-element
         ("M-r" . consult-history))                ;; orig. previous-matching-history-element

  ;; Enable automatic preview at point in the *Completions* buffer. This is
  ;; relevant when you use the default completion UI.
  :hook (completion-list-mode . consult-preview-at-point-mode)

  ;; The :init configuration is always executed (Not lazy)
  :init

  ;; Tweak the register preview for `consult-register-load',
  ;; `consult-register-store' and the built-in commands.  This improves the
  ;; register formatting, adds thin separator lines, register sorting and hides
  ;; the window mode line.
  (advice-add #'register-preview :override #'consult-register-window)
  (setq register-preview-delay 0.5)

  ;; Use Consult to select xref locations with preview
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  ;; Configure other variables and modes in the :config section,
  ;; after lazily loading the package.
  :config

  ;; Optionally configure preview. The default value
  ;; is 'any, such that any key triggers the preview.
  ;; (setq consult-preview-key 'any)
  ;; (setq consult-preview-key "M-.")
  ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
  ;; For some commands and buffer sources it is useful to configure the
  ;; :preview-key on a per-command basis using the `consult-customize' macro.
  (consult-customize
   consult-theme :preview-key '(:debounce 0.2 any)
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   consult--source-bookmark consult--source-file-register
   consult--source-recent-file consult--source-project-recent-file
   ;; :preview-key "M-."
   :preview-key '(:debounce 0.4 any))

  ;; Optionally configure the narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; "C-+"

  ;; Optionally make narrowing help available in the minibuffer.
  ;; You may want to use `embark-prefix-help-command' or which-key instead.
  ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
)
#+end_src

**** Use consult-ripgrep instead of project-find-regexp in project.el

[[https://github.com/minad/consult/wiki#use-consult-ripgrep-instead-of-project-find-regexp-in-projectel][Config from the wiki]]

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
  (require 'keymap) ;; keymap-substitute requires emacs version 29.1?
  (require 'cl-seq)
  (require 'project)

  (keymap-substitute project-prefix-map #'project-find-regexp #'consult-ripgrep)
  (cl-nsubstitute-if
    '(consult-ripgrep "Find regexp")
    (pcase-lambda (`(,cmd _)) (eq cmd #'project-find-regexp))
    project-switch-commands)
#+end_src

** Embark

#+begin_src nix :noweb-ref epkgs
  epkgs.embark
  epkgs.embark-consult
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
(use-package embark
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))

;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure t ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** consult embark integration

[[https://github.com/minad/consult?tab=readme-ov-file#embark-integration][consult embark integration]]

** Corfu

#+begin_quote
Corfu enhances in-buffer completion with a small completion popup. The
current candidates are shown in a popup below or above the point, and
can be selected by moving up and down. Corfu is the minimalistic
in-buffer completion counterpart of the Vertico minibuffer UI.
#+end_quote

[[https://github.com/minad/corfu][Corfu]]

I’m probably going to want to activate ~corfu-cycle~.

#+begin_src nix :noweb-ref epkgs
  epkgs.corfu
#+end_src
#+begin_src emacs-lisp :noweb-ref pembrokensis-completion-ui
(use-package corfu
  ;; Optional customizations
  ;; :custom
  ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
  ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
  ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
  ;; (corfu-preview-current nil)    ;; Disable current candidate preview
  ;; (corfu-preselect 'prompt)      ;; Preselect the prompt
  ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches

  ;; Enable Corfu only for certain modes. See also `global-corfu-modes'.
  ;; :hook ((prog-mode . corfu-mode)
  ;;        (shell-mode . corfu-mode)
  ;;        (eshell-mode . corfu-mode))

  ;; Recommended: Enable Corfu globally.  This is recommended since Dabbrev can
  ;; be used globally (M-/).  See also the customization variable
  ;; `global-corfu-modes' to exclude certain modes.
  :init
  (global-corfu-mode))

;; A few more useful configurations...
(use-package emacs
  :custom
  ;; TAB cycle if there are only few candidates
  ;; (completion-cycle-threshold 3)

  ;; Enable indentation+completion using the TAB key.
  ;; `completion-at-point' is often bound to M-TAB.
  (tab-always-indent 'complete)

  ;; Emacs 30 and newer: Disable Ispell completion function.
  ;; Try `cape-dict' as an alternative.
  (text-mode-ispell-word-completion nil)

  ;; Hide commands in M-x which do not apply to the current mode.  Corfu
  ;; commands are hidden, since they are not used via M-x. This setting is
  ;; useful beyond Corfu.
  (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

* Commands

This is stolen from corgi-commands

#+begin_src emacs-lisp
  ;; The few custom commands that we ship with. This includes a few things we
  ;; emulate from Spacemacs, and commands for jumping to the user's init.el
  ;; (this file, with `SPC f e i'), or opening the user's key binding or signals
  ;; file.
  ;; (use-package corgi-commands)
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-commands
  (use-package corgi-commands
    :load-path "corgi-packages/corgi-commands/")
#+end_src

* Clojure

This is stolen from corgi-clojure

#+begin_src emacs-lisp
  ;; Extensive setup for a good Clojure experience, including clojure-mode,
  ;; CIDER, and a modeline indicator that shows which REPLs your evaluations go
  ;; to.
  ;; Also contains `corgi/cider-pprint-eval-register', bound to `,,', see
  ;; `set-register' calls below.
  ;; (use-package corgi-clojure)
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-clojure
    (use-package corgi-clojure
      :load-path "corgi-packages/corgi-clojure/")
#+end_src

* Emacs Lisp

This is stolen from corgi-emacs-lisp

#+begin_src emacs-lisp
  ;; Emacs Lisp config, mainly to have a development experience that feels
  ;; similar to using CIDER and Clojure. (show results in overlay, threading
  ;; refactorings)
  ;;  (use-package corgi-emacs-lisp)
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-emacs-lisp
    (use-package corgi-emacs-lisp
      :load-path "corgi-packages/corgi-emacs-lisp/")
#+end_src

* corgi-stateline

I suppose I'm just using corgi-stateline

#+begin_src emacs-lisp
  ;; Change the color of the modeline based on the Evil state (e.g. green when
  ;; in insert state)
  (use-package corgi-stateline
    :load-path "corgi-packages/corgi-stateline/"
    :config
    (global-corgi-stateline-mode))
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-stateline
#+end_src


* corgi-bindings

#+begin_src emacs-lisp
  ;; Package which provides corgi-keys and corgi-signals, the two files that
  ;; define all Corgi bindings, and the default files that Corkey will look for.
  ;; (use-package corgi-bindings)
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-corgi-bindings
      (use-package corgi-bindings
        :load-path "corgi-packages/corgi-bindings/")
#+end_src


* corkey

#+begin_src emacs-lisp :noweb-ref pembrokensis-corkey
  ;; Corgi's keybinding system, which builds on top of Evil. See the manual, or
  ;; visit the key binding and signal files (with `SPC f e k', `SPC f e K', `SPC
  ;; f e s' `SPC f e S')
  ;; Put this last here, otherwise keybindings for commands that aren't loaded
  ;; yet won't be active.
  (use-package corkey
    :vc ( :url "https://github.com/corgi-emacs/corkey.git")
    :config
    (corkey-mode 1)
    ;; Automatically pick up keybinding changes
    (corkey/load-and-watch))
#+end_src

#+begin_src emacs-lisp :noweb-ref pembrokensis-corkey
#+end_src

* evil-escape

#+begin_src nix :noweb-ref epkgs
  epkgs.evil-escape
#+end_src

#+begin_src emacs-lisp :noweb-ref evil-escape
  ;; Customizable key sequence to escape from insert state. Defaults to `fd'
  (use-package evil-escape
    :diminish evil-escape-mode
    :config
    (evil-escape-mode))
#+end_src

* Javascript

#+begin_src emacs-lisp
  ;; REPL-driven development for JavaScript, included as an example of how to
  ;; configure signals, see `user-signal.el' (visit it with `SPC f e s')
  ;; (use-package js-comint)
#+end_src

* Magit and VC modes

** Magit

#+begin_src nix :noweb-ref epkgs
  epkgs.magit
#+end_src


#+NAME: magit
#+begin_src emacs-lisp
  ;; Powerful Git integration. Corgi already ships with a single keybinding for
  ;; Magit, which will be enabled if it's installed (`SPC g s' or `magit-status').
  (use-package magit
    :init
    (when ubuntu-p
      (package-install 'magit)))

#+end_src


* Coda

** emacs server

We’ll want to activate this when we switch over to using this config.

#+begin_src emacs-lisp :noweb-ref init-coda
  ;; (use-package server
  ;;   :config (or (server-running-p) (server-mode)))
#+end_src

** TODO Put in auto tangle hook

I think this is from Howardism
